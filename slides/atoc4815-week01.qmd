---
title: "ATOC 4815/5815"
subtitle: "Python Fundamentals - Week 1"
author: "Will Chapman"
institute: "CU Boulder ATOC"
date: "Spring 2026"
format:
  revealjs:
    theme: [default, custom.scss]
    slide-number: true
    chalkboard: true
    preview-links: auto
    logo: ../images/william_chapman_square.jpg
    css: styles.css
    footer: "ATOC 4815/5815 - Week 1"
    highlight-style: github
    width: 1280
    height: 720
    margin: 0.15
    max-scale: 2.0
    min-scale: 0.2
    scrollable: false
---

# Python Fundamentals I {background-color="#2F2F2F"}

## Today's Objectives

::: {.incremental}
- Understand **why** Python for atmospheric science
- Work with essential data types (numbers, strings, lists)
- Access and manipulate data with indexing
- Organize data with dictionaries
- Control program flow with if/else and loops
- Write reusable functions
:::

## Reminders

:::: {.columns}
::: {.column width="50%"}
::: {.tiny}
**Due Sunday at 12pm:**

- Lab 2
- HW2

**Office Hours:**

**Will**: Tu / Th 11:15-12:15p Aerospace Cafe

**Aiden**: M / W 4-5p DUAN D319 
:::
:::
::: {.column width="50%"}
::: {.tiny}
![DUAN Building](./Duan_image.png)
:::
:::
::::

# Python Ecosystem {background-color="#9CA898"}

## Why Python for Atmospheric Science?

:::: {.columns}
::: {.column width="50%"}
**What You'll Do:**
- Read NetCDF climate data files
- Process time series (temperature, precipitation)
- Create maps and plots
- Run statistical analyses
- Automate repetitive tasks
:::

::: {.column width="50%"}
**Why Python?**
- Free and open source
- Huge scientific community
- Libraries: NumPy, Pandas, Xarray
- Same tool for analysis AND visualization
- Reproducible research
:::
::::

## <u>Two Ways to Write Python</u>

:::: {.columns}
::: {.column width="50%"}
### Notebook (`.ipynb`)
- Jupyter / VS Code
- **When:** Exploring data, prototyping
- Mix code, text, plots
- Great for: homework, reports
- **Example:** "Let me see what this dataset looks like"
:::

::: {.column width="50%"}
### Script (`.py`)
- Plain text file
- **When:** Production code, automation
- Version control friendly
- Run on HPC clusters
- **Example:** "Process 100 years of data overnight"
:::
::::

::: {.fragment}
**Pro tip:** Start in notebook ‚Üí Move working code to scripts ‚Üí Import scripts into notebooks
:::

# Variables & Types {background-color="#2F2F2F"}

## Variables: Labeled Boxes for Data

Think of a variable as a **labeled box** that holds a value:

```{python}
#| echo: true
#| eval: true
# The box labeled "temperature" holds the value 20.5
temperature = 20.5
print(temperature)
```

:::: {.columns}
::: {.column width="50%"}
**Good Names** ‚úÖ
```python
temperature_celsius = 20.5
station_elevation = 1655
wind_speed_ms = 12.3
```
:::

::: {.column width="50%"}
**Bad Names** ‚ùå
```python
t = 20.5  # What is t?
x = 1655  # Elevation? Pressure?
a = 12.3  # Unclear
```
:::
::::

::: {.fragment}
**Why it matters:** You'll read your code 10√ó more than you write it!
:::

## Python is Case Sensitive

These are **three different variables:**

```{python}
#| echo: true
#| eval: true
temperature = 20
Temperature = 25
TEMPERATURE = 30

print(f"temperature = {temperature}")
print(f"Temperature = {Temperature}")
print(f"TEMPERATURE = {TEMPERATURE}")
```

::: {.fragment}
‚ö†Ô∏è Common mistake: calling `Temperature` when you meant `temperature`
:::

## Essential Data Types {.smaller}

Python has **several data types**. For now, focus on these:

:::: {.columns}
::: {.column width="50%"}
### Numbers
```{python}
#| echo: true
#| eval: true
# Integer (whole numbers)
days = 365
print(f"days: {days}, type: {type(days)}")

# Float (decimals)
temp = 20.5
print(f"temp: {temp}, type: {type(temp)}")
```
:::

::: {.column width="50%"}
### Text
```{python}
#| echo: true
#| eval: true
# String (text in quotes)
location = "Boulder"
print(f"location: {location}")
print(f"type: {type(location)}")
```
:::
::::

::: {.fragment .tiny}
**Note:** There are other types (complex, boolean, None) - we'll see them later when needed
:::

## Check Your Understanding ü§î

**What will this print?**

```python
temperature = "20"
pressure = 1013

print(type(temperature))
print(type(pressure))
```

::: {.fragment}
**Answer:**
```
<class 'str'>
<class 'int'>
```

‚ö†Ô∏è `"20"` in quotes is a string, not a number!
:::

## Common Type Error

**Predict the output:**

```python
temperature = "20"
adjustment = 5
result = temperature + adjustment
```

::: {.fragment}
```
TypeError: can only concatenate str (not "int") to str
```

**The Fix:**
```{python}
#| echo: true
#| eval: true
temperature = "20"
adjustment = 5
result = int(temperature) + adjustment  # Convert string to int
print(result)
```
:::

# Numeric Operations {background-color="#9CA898"}

## Basic Math Operations

Python follows standard math rules (PEMDAS):

:::: {.columns}
::: {.column width="50%"}
```{python}
#| echo: true
#| eval: true
# Addition, subtraction
temp_day = 20
temp_night = 15
temp_range = temp_day - temp_night
print(f"Range: {temp_range}¬∞C")
```

```{python}
#| echo: true
#| eval: true
# Multiplication, division
wind_kmh = 36
wind_ms = wind_kmh / 3.6
print(f"Wind: {wind_ms} m/s")
```
:::

::: {.column width="50%"}
```{python}
#| echo: true
#| eval: true
# Exponentiation
area_km = 10
area_m = area_km ** 2  # 10 squared
print(f"Area: {area_m} km¬≤")
```

```{python}
#| echo: true
#| eval: true
# Modulus (remainder)
hours = 25
days = hours % 24
print(f"Remainder: {days} hours")
```
:::
::::

## Atmospheric Science Example

Calculate **apparent temperature** (feels-like temperature):

```{python}
#| echo: true
#| eval: true
# Steadman's formula (simplified)
temperature_c = 20
wind_speed_kmh = 30
humidity_percent = 60

# Apparent temperature calculation
wind_chill = temperature_c - 0.4 * (temperature_c - 10) * wind_speed_kmh / 36
print(f"Actual: {temperature_c}¬∞C")
print(f"Feels like: {wind_chill:.1f}¬∞C")
```

::: {.fragment}
**Key takeaway:** Use descriptive variable names and comments for complex formulas
:::

# Strings {background-color="#2F2F2F"}

## Working with Text Data

Strings hold text - essential for file paths, station names, labels:

```{python}
#| echo: true
#| eval: true
# Single or double quotes both work
station_name = "Boulder"
data_source = 'NOAA'

# Combining strings
full_name = station_name + " (" + data_source + ")"
print(full_name)
```

## F-Strings: Modern String Formatting {.smaller}

**The old way** (avoid):
```python
print("Station: " + station + ", Temp: " + str(temperature) + "¬∞C")
```

**The modern way** (use this!):
```{python}
#| echo: true
#| eval: true
station = "Boulder"
temperature = 20.547

# Put variables directly in the string with f""
message = f"Station: {station}, Temp: {temperature}¬∞C"
print(message)

# Control decimal places
message = f"Station: {station}, Temp: {temperature:.1f}¬∞C"
print(message)
```

::: {.fragment}
**Why f-strings?** Cleaner, faster, fewer errors than old methods
:::

## Try It Yourself üíª

**With your neighbor (2 min):** What does this print?

```python
city = "Denver"
elevation = 1609  # meters
temp = 15.7

report = f"{city} (elevation {elevation}m): {temp:.0f}¬∞C"
print(report)
```

::: {.fragment}
**Answer:**
```
Denver (elevation 1609m): 16¬∞C
```
Note: `.0f` rounds to 0 decimal places
:::

# Lists & Indexing {background-color="#9CA898"}

## Why Lists? ‚Üí Time Series Data!

**Atmospheric data is often sequential:**
- Hourly temperatures over a day
- Daily rainfall over a month
- Pressure readings from a sensor

**Lists** store ordered sequences:

```{python}
#| echo: true
#| eval: true
# Temperature readings every hour (24 values)
temps = [15.2, 14.8, 14.5, 14.1, 14.0, 14.2,
         15.0, 16.5, 18.2, 20.1, 21.5, 22.3]

print(f"First reading: {temps[0]}¬∞C")
print(f"Number of readings: {len(temps)}")
```

## Python Indexing: Start at 0 {.smaller}

**Coming from Matlab/Fortran?** This is different!

:::: {.columns}
::: {.column width="50%"}
### Python (0-indexed)
```
temps = [15.2, 18.7, 22.1, 19.8]
         ‚Üì     ‚Üì     ‚Üì     ‚Üì
Index:   0     1     2     3
```

```{python}
#| echo: true
#| eval: true
temps = [15.2, 18.7, 22.1, 19.8]
print(f"First: temps[0] = {temps[0]}")
print(f"Second: temps[1] = {temps[1]}")
```
:::

::: {.column width="50%"}
### Why 0-indexing?
- Array offset from memory address
- Most programming languages use it
- Makes math simpler: `length = end - start`

**Negative indices** count from end:
```{python}
#| echo: true
#| eval: true
temps = [15.2, 18.7, 22.1, 19.8]
print(f"Last: temps[-1] = {temps[-1]}")
print(f"Second to last: temps[-2] = {temps[-2]}")
```
:::
::::

## Common Index Error

**Predict what happens:**

```python
temps = [15.2, 18.7, 22.1]  # 3 items (indices 0,1,2)
print(temps[3])  # Try to access index 3
```

::: {.fragment}
```
IndexError: list index out of range
```

**Remember:** For a list of length `n`, valid indices are `0` to `n-1`

```{python}
#| echo: true
#| eval: true
temps = [15.2, 18.7, 22.1]
print(f"Length: {len(temps)}")
print(f"Valid indices: 0 to {len(temps)-1}")
print(f"Last item: temps[{len(temps)-1}] = {temps[len(temps)-1]}")
```
:::

## Slicing: Extracting Ranges {.smaller}

Get multiple elements with **slicing**: `list[start:stop:step]`

```{python}
#| echo: true
#| eval: true
temps = [10, 12, 15, 18, 20, 22, 21, 19, 16, 14, 12, 11]  # 12 hourly readings
```

:::: {.columns}
::: {.column width="50%"}
```{python}
#| echo: true
#| eval: true
# First 3 values (indices 0,1,2)
morning = temps[0:3]
print(f"Morning: {morning}")

# Shortcut: omit 0
morning = temps[:3]
print(f"Morning: {morning}")
```
:::

::: {.column width="50%"}
```{python}
#| echo: true
#| eval: true
# Last 3 values
evening = temps[-3:]
print(f"Evening: {evening}")

# Every other value (step=2)
every_2hrs = temps[::2]
print(f"Every 2hrs: {every_2hrs}")
```
:::
::::

::: {.fragment}
**Key insight:** `[start:stop]` includes start, excludes stop (like `range()`)
:::

## Check Your Understanding ü§î {.smaller}

**What will this print?**

```python
daily_temps = [12, 14, 16, 18, 20, 19, 17, 15]

print(daily_temps[2:5])
print(daily_temps[::3])
print(daily_temps[-2])
```

::: {.fragment}
**Answer:**
```{python}
#| echo: true
#| eval: true
daily_temps = [12, 14, 16, 18, 20, 19, 17, 15]

print(daily_temps[2:5])    # [16, 18, 20]  (indices 2,3,4)
print(daily_temps[::3])    # [12, 18, 17]  (every 3rd)
print(daily_temps[-2])     # 17           (second from end)
```
:::

# Dictionaries {background-color="#2F2F2F"}

## Why Dictionaries? ‚Üí Station Metadata!

**Real atmospheric data has attributes:**
- Station name, location, elevation
- Variable names and units
- Quality control flags

**Dictionaries** store key-value pairs:

```{python}
#| echo: true
#| eval: true
station = {
    "name": "Boulder",
    "lat": 40.01,
    "lon": -105.25,
    "elevation": 1655,
    "active": True
}

print(f"Station: {station['name']}")
print(f"Elevation: {station['elevation']}m")
```

## Accessing Dictionary Values

**Use square brackets with the key:**

```{python}
#| echo: true
#| eval: true
station = {
    "name": "Boulder",
    "temp_c": 20.5,
    "pressure_hpa": 835
}

# Access values
name = station["name"]
temp = station["temp_c"]
print(f"{name}: {temp}¬∞C")
```

::: {.fragment}
‚ö†Ô∏è **Not dot notation!** `station.name` won't work (common mistake from other languages)
:::

## Common Dictionary Error

**Predict what happens:**

```python
station = {"name": "Boulder", "temp_c": 20.5}
print(station["humidity"])  # Key doesn't exist
```

::: {.fragment}
```
KeyError: 'humidity'
```

**The Safe Way:**
```{python}
#| echo: true
#| eval: true
station = {"name": "Boulder", "temp_c": 20.5}

# Use .get() with default value
humidity = station.get("humidity", "N/A")
print(f"Humidity: {humidity}")

# Check if key exists
if "humidity" in station:
    print(station["humidity"])
else:
    print("Humidity not available")
```
:::

## Lists vs Dictionaries: When to Use Each?

:::: {.columns}
::: {.column width="50%"}
::: {.small}
### Use a **List** when:
:::
::: {.tiny}
- ‚úÖ Order matters
- ‚úÖ Sequential data (time series)
- ‚úÖ Access by position
- ‚úÖ All same type of thing

**Example:**
```python
temperatures = [15, 16, 18, 20, 19]
```
:::
:::

::: {.column width="50%"}
::: {.small}
### Use a **Dictionary** when:
:::
::: {.tiny}
- ‚úÖ Named attributes
- ‚úÖ Metadata / properties
- ‚úÖ Access by name
- ‚úÖ Mixed types

**Example:**
```python
station = {
    "name": "Boulder",
    "temp": 20.5,
    "active": True
}
```
:::
:::
::::

# Control Flow {background-color="#9CA898"}

## Making Decisions with if/elif/else

**Programs need to make decisions:**

::: {.tiny}
- "If temperature < 0, issue frost warning"
- "If wind speed > 15, flag as high wind day"
:::
```{python}
#| echo: true
#| eval: true
temperature = 25

if temperature >= 30:
    print("Hot day! Stay hydrated")
elif temperature >= 20:
    print("Pleasant day")
elif temperature >= 10:
    print("Cool day, bring a jacket")
else:
    print("Cold day!")
```

## Comparison Operators

Use these to create conditions:

:::: {.columns}
::: {.column width="50%"}
```{python}
#| echo: true
#| eval: true
temp = 20

print(f"temp == 20: {temp == 20}")  # Equal
print(f"temp != 15: {temp != 15}")  # Not equal
print(f"temp > 15: {temp > 15}")    # Greater than
print(f"temp <= 20: {temp <= 20}")  # Less or equal
```
:::

::: {.column width="50%"}
**Combine conditions:**
```{python}
#| echo: true
#| eval: true
temp = 22
humid = 70

# Both conditions must be True
if temp > 20 and humid > 60:
    print("Warm and humid")

# Either condition can be True
if temp > 30 or humid > 80:
    print("Uncomfortable conditions")
```
:::
::::

## Python Syntax: Indentation Matters! {.smaller}

**Python uses indentation** to show code blocks:

:::: {.columns}
::: {.column width="50%"}
‚úÖ **Correct:**
```python
if temperature > 20:
    print("It's warm")
    print("Stay cool!")
print("This always runs")
```

**Output:**
```
It's warm
Stay cool!
This always runs
```
:::

::: {.column width="50%"}
‚ùå **Wrong indentation:**
```python
if temperature > 20:
print("It's warm")  # IndentationError!
```

**Rules:**

::: {.small}
- Use 4 spaces (not tabs!)
- `:` starts a block
- All lines in block must align
- Blank lines OK
:::
:::
::::

::: {.fragment}
**Pro tip:** Configure your editor to insert 4 spaces when you press Tab
:::

## Try It Yourself üíª

**With your neighbor (3 min):** What does this print when `temp = 18` and `wind = 25`?

```python
temp = 18
wind = 25

if temp < 10:
    print("Cold!")
elif temp < 20 and wind > 20:
    print("Chilly and windy")
elif temp < 20:
    print("Mild weather")
else:
    print("Warm day")
```

::: {.fragment}
**Answer:** `"Chilly and windy"` (meets second condition)
:::

# Loops & Iteration {background-color="#2F2F2F"}

## Why Loops? ‚Üí Process Multiple Measurements

**Atmospheric science = LOTS of data:**

::: {.tiny}
- Convert 100 temperature values from C to F
- Calculate statistics on 1000 measurements
- Process files from 50 weather stations

**Loops** repeat operations:


```{python}
#| echo: true
#| eval: true
temps_c = [15.2, 18.7, 22.1]

for temp in temps_c:
    temp_f = temp * 9/5 + 32
    print(f"{temp}¬∞C = {temp_f:.1f}¬∞F")
```
:::
## For Loop Anatomy

**Structure:** `for item in sequence:`

```python
for temperature in daily_temps:
    # Code here runs once for each temperature
    # 'temperature' holds the current value
    print(temperature)
```

:::: {.columns}
::: {.column width="50%"}
**Loop over a list:**
```{python}
#| echo: true
#| eval: true
stations = ["Boulder", "Denver", "Vail"]

for station in stations:
    print(f"Processing {station}")
```
:::

::: {.column width="50%"}
**Loop with range:**
```{python}
#| echo: true
#| eval: true
# range(n) gives 0,1,2,...,n-1
for i in range(3):
    print(f"Iteration {i}")
```
:::
::::

## Loop with Index (When You Need Position) {.small}

::: {.tiny}
Sometimes you need both the **value** and its **position**:
:::

```{python}
#| echo: true
#| eval: true
temps = [15.2, 18.7, 22.1]

# Method 1: Loop with range(len())
for i in range(len(temps)):
    print(f"Hour {i}: {temps[i]}¬∞C")
```

```{python}
#| echo: true
#| eval: true
# Method 2: enumerate (better!)
for i, temp in enumerate(temps):
    print(f"Hour {i}: {temp}¬∞C")
```

::: {.fragment .tiny}
**Prefer `enumerate`** - cleaner and less error-prone
:::

## While Loops: Use with Caution

**For loops:** "Do this N times" (most common)

**While loops:** "Do this until condition is False" (less common, risky)

```{python}
#| echo: true
#| eval: true
# Keep reading data until threshold met
measurement = 10
readings = []

while measurement < 20 and len(readings) < 5:
    readings.append(measurement)
    measurement += 2  # Simulate new reading

print(f"Readings: {readings}")
```

::: {.fragment}
‚ö†Ô∏è **Danger:** If condition never becomes False ‚Üí infinite loop!
Make sure loop will eventually exit.
:::

# Functions {background-color="#9CA898"}

## Why Functions? ‚Üí Reusable Code {.small}

::: {.tiny}
**You'll write the same operations repeatedly:**

- Convert temperature units
- Calculate saturation vapor pressure
- Read a specific data file format
:::

**Functions** make code reusable and testable:

```{python}
#| echo: true
#| eval: true
def celsius_to_fahrenheit(temp_c):
    """Convert Celsius to Fahrenheit"""
    temp_f = temp_c * 9/5 + 32
    return temp_f

# Now use it many times!
print(f"20¬∞C = {celsius_to_fahrenheit(20)}¬∞F")
print(f"0¬∞C = {celsius_to_fahrenheit(0)}¬∞F")
print(f"-40¬∞C = {celsius_to_fahrenheit(-40)}¬∞F")
```

## Function Anatomy {.smaller}

```python
def function_name(parameter1, parameter2):
    """
    Docstring: Explain what the function does

    Args:
        parameter1: Description
        parameter2: Description
    Returns:
        Description of return value
    """
    # Function body
    result = parameter1 + parameter2
    return result
```

::: {.smaller}

**Key parts:**

1. `def` starts function definition
2. Name should be descriptive (use_underscores)
3. Parameters in parentheses
4. Docstring explains function (not optional!)
5. `return` sends value back
:::

## Function with Multiple Parameters

```{python}
#| echo: true
#| eval: true
def wind_chill(temp_c, wind_kmh):
    """
    Calculate wind chill temperature

    Args:
        temp_c: Air temperature in Celsius
        wind_kmh: Wind speed in km/h
    Returns:
        Wind chill temperature in Celsius
    """
    if wind_kmh < 4.8:  # No wind chill at low speeds
        return temp_c

    wc = 13.12 + 0.6215*temp_c - 11.37*(wind_kmh**0.16) + 0.3965*temp_c*(wind_kmh**0.16)
    return round(wc, 1)

# Test the function
print(f"Wind chill: {wind_chill(-10, 30)}¬∞C")
print(f"Wind chill: {wind_chill(20, 5)}¬∞C")
```

## Common Function Mistake

**Defining ‚â† Running:**

```{python}
#| echo: true
#| eval: true
# This DEFINES the function (but doesn't run it)
def calculate_average(values):
    """Calculate the mean of a list"""
    return sum(values) / len(values)

# Nothing happened yet!

# This CALLS (runs) the function
temps = [15, 18, 20, 19]
avg = calculate_average(temps)
print(f"Average: {avg}¬∞C")
```

::: {.fragment}
Think of it like: Define = "write recipe", Call = "cook the food"
:::

## When Should You Write a Function? {.small}

::: {.tiny}

**Good candidates for functions:**

- ‚úÖ Code you copy-paste more than twice
- ‚úÖ Complex calculation you'll reuse
- ‚úÖ Task you want to test independently
- ‚úÖ Code that has a clear purpose

**Example:**
```{python}
#| echo: true
#| eval: true
def quality_control_temp(temp):
    """Flag suspicious temperature readings"""
    if temp < -50 or temp > 50:
        return "SUSPECT"
    elif temp < -40 or temp > 45:
        return "CHECK"
    else:
        return "OK"

# Easy to use and test!
print(quality_control_temp(20))    # OK
print(quality_control_temp(100))   # SUSPECT
```
:::

# Python Fundamentals II {background-color="#2F2F2F" .tiny}

## Today's Objectives (Part II)

::: {.incremental}
- Combine data structures (lists of dictionaries)
- Develop effective debugging strategies
- Write clear documentation and comments
- Practice with realistic atmospheric examples
- Prepare for your first homework
:::

## Quick Review: Check Your Understanding

**1. What's wrong with this code?**
```python
temps = [10, 15, 20]
print(temps[3])
```

**2. How do you safely access a dictionary key?**

**3. What does this output?**
```python
for i in range(3):
    print(i * 2)
```

::: {.fragment .smaller}
**Answers:** 1) IndexError (index 3 doesn't exist), 2) Use `.get()`, 3) Prints 0, 2, 4
:::

# Combining Data Structures {background-color="#9CA898" .tiny}

## Real Data = Complex Structures {.small}

**Atmospheric datasets combine multiple types:**

```{python}
#| echo: true
#| eval: true
# List of weather stations (each is a dictionary)
stations = [
    {
        "name": "Boulder",
        "lat": 40.01,
        "temps": [15, 18, 20, 19, 16]  # List inside dictionary!
    },
    {
        "name": "Denver",
        "lat": 39.74,
        "temps": [17, 20, 22, 21, 18]
    }
]

# Access nested data
print(f"Station: {stations[0]['name']}")
print(f"First temp at Boulder: {stations[0]['temps'][0]}¬∞C")
```

## Processing Complex Data {.small}

**Loop through stations and analyze each:**

```{python}
#| echo: true
#| eval: true
stations = [
    {"name": "Boulder", "temps": [15, 18, 20, 19, 16]},
    {"name": "Denver", "temps": [17, 20, 22, 21, 18]}
]

for station in stations:
    name = station["name"]
    temps = station["temps"]
    avg_temp = sum(temps) / len(temps)
    max_temp = max(temps)

    print(f"{name}:")
    print(f"  Average: {avg_temp:.1f}¬∞C")
    print(f"  Maximum: {max_temp}¬∞C")
```

## Practical Example: Data Quality

```{python}
#| echo: true
#| eval: true
def flag_outliers(measurements, threshold=2):
    """Flag measurements > threshold std devs from mean"""
    import statistics

    mean = statistics.mean(measurements)
    stdev = statistics.stdev(measurements)

    flagged = []
    for i, value in enumerate(measurements):
        z_score = abs(value - mean) / stdev
        if z_score > threshold:
            flagged.append({"index": i, "value": value, "z_score": z_score})

    return flagged

# Test with outlier
temps = [20, 21, 19, 22, 200, 20, 14, 14, 22]  # 200 is clearly wrong
outliers = flag_outliers(temps)
print(f"Found {len(outliers)} outliers: {outliers}")
```

# Debugging {background-color="#2F2F2F"}

## Debugging Mindset: Errors Are Learning {.small}

**Everyone writes bugs. Even experienced programmers.**

The difference: Experienced programmers debug efficiently.

:::: {.columns}
::: {.column width="50%"}
::: {.incremental .compact .small}
1. **Slow down and read the error**
   - What line failed?
   - What's the error type?
   - What does message say?
2. **Compare expected vs. actual**
   - Print variables
   - Check types: `print(type(x))`
   - Check shapes: `print(len(data))`
:::
:::

::: {.column width="50%"}
::: {.incremental .compact .small}
3. **Make the bug smaller**
   - Create minimal example
   - Comment out code
   - Test one piece at a time
4. **Get help effectively**
   - Google the error message
   - Stack Overflow (likely answered!)
   - Show: code, error, what you expected
:::
:::
::::

## Common Errors You'll See {.smaller}

**1. IndexError**
```python
temps = [10, 15, 20]
print(temps[5])  # Only indices 0,1,2 exist
# IndexError: list index out of range
```

**2. KeyError**
```python
station = {"name": "Boulder"}
print(station["temp"])  # Key doesn't exist
# KeyError: 'temp'
# Fix: Use station.get("temp", default_value)
```

**3. TypeError**
```python
temp = "20"
result = temp + 5  # Can't add string and int
# TypeError: can only concatenate str (not "int") to str
# Fix: result = int(temp) + 5
```

## Debugging Strategies {.smaller}

::: {.smaller}
**Strategy 1: Print Everything**
```{python}
#| echo: true
#| eval: true
temps = [15, 18, 20]

for i, temp in enumerate(temps):
    print(f"i={i}, temp={temp}, type={type(temp)}")  # Debug print
    temp_f = temp * 9/5 + 32
    print(f"temp_f={temp_f}")  # Debug print
```

**Strategy 2: Test with Simple Data**
```python
# Instead of 10,000 values, test with 3
temps = [10, 15, 20]  # Easier to verify output
```

**Strategy 3: Add Assert Statements**
```{python}
#| echo: true
#| eval: true
def celsius_to_fahrenheit(temp_c):
    assert isinstance(temp_c, (int, float)), "temp must be a number"
    assert temp_c >= -273.15, "temp below absolute zero"
    return temp_c * 9/5 + 32

# This will catch bugs early
print(celsius_to_fahrenheit(20))
```
:::

## Debugging Exercise üíª

**This code has bugs. Find them with your neighbor (5 min):**

```python
stations = ["Boulder", "Denver", "Vail"]
temps = [20, 22, 18]

# Calculate average temperature
total = 0
for i in range(len(stations) + 1):  # Bug 1
    print(f"Station: {stations[i]}, Temp: {temps[i]}")
    total = total + temps[i]

average = total / len(stations)
print(f"Average: {average}")
```

::: {.fragment}
**Bugs:**
1. `range(len(stations) + 1)` ‚Üí IndexError (goes to 4, but only 3 items)
2. **Fix:** `range(len(stations))`
:::

# Documentation {background-color="#9CA898"}

## Why Comment Your Code? {.smaller}

::: {.tiny}
**You are writing for:**

1. **Future you** (6 months from now, you'll forget)
2. **Collaborators** (lab mates, advisor)
3. **Your published research** (reproducibility!)
:::

```{python}
#| echo: true
#| eval: true
# Calculate potential temperature
# Œò = T * (P0/P)^(R/cp)
# where P0 = 1000 hPa, R/cp = 0.286

def potential_temperature(temp_k, pressure_hpa):
    """
    Calculate potential temperature

    Args:
        temp_k: Temperature in Kelvin
        pressure_hpa: Pressure in hPa
    Returns:
        Potential temperature in Kelvin
    """
    P0 = 1000  # Reference pressure (hPa)
    kappa = 0.286  # R/cp for dry air
    return temp_k * (P0 / pressure_hpa) ** kappa

print(f"Theta = {potential_temperature(280, 850):.1f}K")
```

## Good vs Bad Comments

:::: {.columns}
::: {.column width="50%"}
‚ùå **Bad (obvious):**
```python
# Increment i
i = i + 1

# Print the temperature
print(temp)
```

‚ùå **Bad (outdated):**
```python
# Convert to Fahrenheit
temp_k = temp_c + 273.15  # WRONG!
```
:::

::: {.column width="50%"}
‚úÖ **Good (explains why):**
```python
# Use 2m temperature (not surface)
# because it's less affected by
# local surface heterogeneity
temp = data['t2m']

# Quality control: flag values
# outside climatological range
# based on Zhang et al. (2020)
if temp < -50 or temp > 50:
    flag_data()
```
:::
::::

::: {.fragment}
**Rule of thumb:** Comment the **why**, not the **what**
:::

## Docstrings: Function Documentation {.tiny}

**Always include docstrings for functions:**

```{python}
#| echo: true
#| eval: true
def saturation_vapor_pressure(temp_c):
    """
    Calculate saturation vapor pressure using Tetens formula

    Valid for temperatures between -40¬∞C and 50¬∞C

    Args:
        temp_c (float): Temperature in Celsius

    Returns:
        float: Saturation vapor pressure in hPa

    Example:
        >>> saturation_vapor_pressure(20)
        23.39

    References:
        Tetens, O. (1930). √úber einige meteorologische Begriffe.
        Zeitschrift f√ºr Geophysik, 6, 297-309.
    """
    return 6.112 * (2.71828 ** ((17.67 * temp_c) / (temp_c + 243.5)))

# Docstring shows up in help!
print(f"es(20¬∞C) = {saturation_vapor_pressure(20):.2f} hPa")
```

## Math Equations in Notebooks {.smaller}

**Jupyter notebooks support LaTeX math** - essential for atmospheric science!

:::: {.columns}
::: {.column width="50%"}
### Inline Math
Use single `$` for inline equations:

**Markdown:**
```markdown
The ideal gas law is $PV = nRT$
where $P$ is pressure.
```

**Renders as:**

The ideal gas law is $PV = nRT$ where $P$ is pressure.
:::

::: {.column width="50%"}
### Display Math
Use double `$$` for centered equations:

**Markdown:**
```markdown
$$ T_f = T_c \times \frac{9}{5} + 32 $$
```

**Renders as:**

$$ T_f = T_c \times \frac{9}{5} + 32 $$
:::
::::

## Atmospheric Science Equations {.smaller}

**Common LaTeX symbols you'll need:**

:::: {.columns}
::: {.column width="50%"}
```markdown
Greek letters:
$\theta$ (theta)
$\rho$ (rho)
$\omega$ (omega)

Subscripts/Superscripts:
$T_2$ or $T_{2m}$
$x^2$ or $x^{n+1}$

Fractions:
$\frac{numerator}{denominator}$
```

**Renders:**
- $\theta$, $\rho$, $\omega$
- $T_2$, $T_{2m}$
- $x^2$, $x^{n+1}$
- $\frac{a}{b}$
:::

::: {.column width="50%"}
**Potential Temperature:**
```markdown
$$ \theta = T \left(\frac{P_0}{P}\right)^{\kappa} $$
where $\kappa = \frac{R}{c_p} = 0.286$
```

**Renders:**
$$ \theta = T \left(\frac{P_0}{P}\right)^{\kappa} $$
where $\kappa = \frac{R}{c_p} = 0.286$
:::
::::

::: {.fragment .tiny}
**Pro tip:** Use [LaTeX equation editor](https://latexeditor.lagrida.com/) to build complex equations visually
:::

# Practice {background-color="#2F2F2F"}

## Putting It All Together üíª

**Work with your neighbor (10 min):**

::: {.tiny}
Given this weather station data, write code to:

1. Calculate the average temperature at each station
2. Find which station is warmest
3. Flag any stations with temperatures outside -50 to 50¬∞C range
:::

```python
stations = [
    {"name": "Boulder", "temps": [20, 22, 21, 19, 20]},
    {"name": "Denver", "temps": [22, 24, 23, 21, 22]},
    {"name": "Vail", "temps": [-5, -2, 0, -3, -4]},
    {"name": "Suspect", "temps": [100, 105, 98, 102, 99]}  # Bad data!
]
```

**Bonus:** Write a function to make it reusable!

## Solution (One Approach) {.smaller}

```{python}
#| echo: true
#| eval: true
stations = [
    {"name": "Boulder", "temps": [20, 22, 21, 19, 20]},
    {"name": "Denver", "temps": [22, 24, 23, 21, 22]},
    {"name": "Vail", "temps": [-5, -2, 0, -3, -4]},
    {"name": "Suspect", "temps": [100, 105, 98, 102, 99]}
]

def analyze_station(station):
    """Calculate stats and QC for a station"""
    temps = station["temps"]
    avg = sum(temps) / len(temps)

    # Quality control
    valid = all(-50 <= t <= 50 for t in temps)

    return {
        "name": station["name"],
        "avg_temp": avg,
        "valid": valid
    }

# Process all stations
results = [analyze_station(s) for s in stations]
valid_results = [r for r in results if r["valid"]]
warmest = max(valid_results, key=lambda x: x["avg_temp"])

print(f"Warmest station: {warmest['name']} ({warmest['avg_temp']:.1f}¬∞C)")
for r in results:
    status = "‚úì" if r["valid"] else "‚úó FLAGGED"
    print(f"{r['name']}: {r['avg_temp']:.1f}¬∞C {status}")
```

## Real-World Challenge üåé

**For homework, you'll work with:**
- Actual NOAA weather station data
- Multiple stations across Colorado
- Calculating degree days (growing season metrics)
- Handling missing data
- Creating summary statistics

**This week's skills prepare you for that!**

# Looking Ahead {background-color="#9CA898"}

## Next Week: NumPy Arrays

**Why arrays?**

- Lists are slow for large datasets
- NumPy arrays = fast vectorized operations
- Designed for scientific computing

**Preview:**
```python
import numpy as np

# List way (slow)
temps_f = []
for temp_c in temps:
    temps_f.append(temp_c * 9/5 + 32)

# NumPy way (fast!)
temps_c = np.array([15, 18, 20, 22])
temps_f = temps_c * 9/5 + 32  # Operates on entire array!
```

## Your Learning Checklist

::: {.tiny}
**Can you:**

- ‚úÖ Explain why Python for atmospheric science?
- ‚úÖ Create and use variables with good names?
- ‚úÖ Work with numbers, strings, lists, dictionaries?
- ‚úÖ Access data with indexing (including negative indices)?
- ‚úÖ Use if/else to make decisions?
- ‚úÖ Write for loops to process data?
- ‚úÖ Write functions with clear docstrings?
- ‚úÖ Debug common errors (Index, Key, Type)?
- ‚úÖ Combine data structures (lists of dicts)?
:::

**If any are unclear, ask now or in office hours!**

## Assignment Reminders

**Due Sunday at 12pm:**

::: {.tiny}
**1. Lab 1**

**2. HW1:**

- Variables and types exercises
- List/dictionary practice with weather data
- Control flow and loops
- Write functions with docstrings
- Debug practice (fix broken code)
:::

::: {.fragment}
**Start early!** Don't wait until Saturday night üòÖ
:::

## Resources

::: {.tiny}
**Stuck on homework?**

- Office hours (Will: Tu/Th 11:15-12:15, Aiden: M/W 4-5)
- Lab notebooks (reference examples)
- Teams Discussion Board
:::

::: {.tiny}

**Online resources:**

- [Python documentation](https://docs.python.org/3/)
- [Real Python tutorials](https://realpython.com/)
- Stack Overflow (search before posting!)
:::

**Remember:** Asking questions is part of learning!

# Questions? {background-color="#2F2F2F"}

## Review: Key Concepts

::: {.tiny}
**Today we covered:**

1. Variables and types (numbers, strings)
2. Lists and 0-based indexing
3. Dictionaries for key-value data
4. Control flow (if/elif/else)
5. Loops (for, while)
6. Functions (def, return, docstrings)
7. Debugging strategies
8. Combining data structures
:::

**Most important:** Practice! Use these skills in Lab 1 and HW1.

## Contact

**Prof. Will Chapman**

üìß wchapman@colorado.edu
üåê willychap.github.io
üè¢ SEEC Building (N258), East Campus

**Office Hours:**

- Will: Tu / Th 11:15-12:15p
- Aiden: M / W 4-5p

**See you next week!**
