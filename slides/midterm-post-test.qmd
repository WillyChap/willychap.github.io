---
title: "ATOC 4815/5815"
subtitle: "Midterm Post-Test"
author: "Will Chapman"
institute: "CU Boulder ATOC"
date: "Spring 2026"
format:
  revealjs:
    theme: [default, custom.scss]
    slide-number: true
    chalkboard: true
    preview-links: auto
    logo: ../images/william_chapman_square.jpg
    css: styles.css
    footer: "ATOC 4815/5815 - Midterm Post-Test"
    highlight-style: github
    width: 1280
    height: 720
    margin: 0.15
    max-scale: 2.0
    min-scale: 0.2
    scrollable: false
---

# Midterm Post-Test {background-color="#2F2F2F"}

## The Three Things That Got You

Let's talk about what tripped people up.

::: {.incremental}
- Two topics: **nested loops**, **why integration needs a loop**
:::

# 1. The Date {background-color="#9CA898"}

## Problem Most Missed on the Entire Exam {.tiny}

::: {.fragment}
> *"What is today's date?"*
:::


# 2. Nested For Loops {background-color="#2F2F2F"}

## The Question {.tiny}

> Using two nested `for` loops over row and column indices, print each entry of `temp_matrix` in the format `temp_matrix[ii, jj] = value` for all valid `ii` and `jj`, in row-major order.
>
> *(Do not use `flatten()`, `ravel()`, `np.nditer`, or vectorized printing.)*

::: {.fragment}
**Setup:**

```{python}
#| echo: true
#| eval: true
import numpy as np
temp_matrix = np.array([[15.2, 18.7, 22.1],
                        [14.8, 17.3, 21.5]])
print(f"Shape: {temp_matrix.shape}")  # (2, 3) — 2 rows, 3 columns
```
:::

## The Common Mistake {.tiny}

Many of you wrote something like:

```python
# WRONG — iterates over rows, not indices
for row in temp_matrix:
    for val in row:
        print(val)
```

::: {.fragment}
**What this does:**

- Prints the *values*: `15.2`, `18.7`, `22.1`, ...
- But you don't have `ii` and `jj` to format the output!
- You're iterating over *elements*, not *indices*
:::

::: {.fragment}
**The question asked for:** `temp_matrix[ii, jj] = value`

You need the **indices**, not just the values.
:::

## The Correct Answer {.tiny}

```{python}
#| echo: true
#| eval: true
n_rows, n_cols = temp_matrix.shape

for ii in range(n_rows):
    for jj in range(n_cols):
        print(f"temp_matrix[{ii}, {jj}] = {temp_matrix[ii, jj]}")
```

## Why This Works {.tiny}

::: {.incremental}
1. **`temp_matrix.shape`** gives `(2, 3)` — unpack into `n_rows` and `n_cols`
2. **Outer loop** `for ii in range(n_rows)` walks through rows: 0, 1
3. **Inner loop** `for jj in range(n_cols)` walks through columns: 0, 1, 2
4. **`temp_matrix[ii, jj]`** grabs the element at row `ii`, column `jj`
5. Inner loop completes all columns before outer loop moves to next row — **row-major order**
:::

## The Pattern to Memorize {.tiny}

**Looping over indices** (when you need `ii`, `jj`):

```python
for ii in range(n_rows):        # outer = rows
    for jj in range(n_cols):    # inner = columns
        do_something(array[ii, jj])
```

::: {.fragment}
**Looping over values** (when you just need the numbers):

```python
for row in array:
    for val in row:
        do_something(val)
```
:::

::: {.fragment}
**Know the difference.** The question tells you which one to use.

- "loop over **indices**" → `range(shape)` + `array[ii, jj]`
- "loop over **elements/values**" → `for val in array`
:::

## Practice: Try It Now {.tiny}

**Given:**

```{python}
#| echo: true
#| eval: true
wind_data = np.array([[5.2, 3.1, 8.7, 2.4],
                       [6.1, 4.5, 7.3, 3.8],
                       [4.9, 2.8, 9.1, 5.0]])
```

Write nested loops to print every element where wind speed exceeds 5.0:

```
wind_data[0, 0] = 5.2 --> WINDY
wind_data[0, 2] = 8.7 --> WINDY
...
```

::: {.fragment}
**Solution:**

```{python}
#| echo: true
#| eval: true
n_rows, n_cols = wind_data.shape

for ii in range(n_rows):
    for jj in range(n_cols):
        if wind_data[ii, jj] > 5.0:
            print(f"wind_data[{ii}, {jj}] = {wind_data[ii, jj]} --> WINDY")
```
:::

# 3. Why Integration Needs a Loop {background-color="#2F2F2F"}

## The Question {.tiny}

> *In the Lorenz63 class, the `integrate()` method uses a loop to advance the model forward in time. Explain in 1-2 sentences why we need a loop for time integration.*

::: {.fragment}
**The common (wrong) answer:**

> *"Because we have many time steps and need to repeat the calculation."*
:::

::: {.fragment}
This is too vague. You could say the same thing about converting 1000 temperatures from Celsius to Fahrenheit — but that **doesn't** need a loop (use NumPy!).

**What makes time integration different?**
:::

## The Correct Answer {.tiny}

::: {.fragment}
> **Each step depends on the previous step.** To compute $y_{n+1}$, we need $y_n$, which itself came from $y_{n-1}$. This is a **sequential dependency** — we cannot compute step 100 without first computing steps 1 through 99.
:::

::: {.fragment}
**Independent** — no loop needed:

```python
# Every element can be computed on its own
temps_f = temps_c * 9/5 + 32
```
:::

::: {.fragment}
**Sequential** — loop required:

```python
# Each step needs the RESULT of the previous step
for i in range(n_steps):
    state = state + tendency(state) * dt
```

The `state` on the right side **is the output of the previous iteration**. You can't skip ahead.
:::

## Sequential vs. Independent {.tiny}

| Operation | Independent? | Loop needed? |
|-----------|:---:|:---:|
| Convert 1000 temps C → F | Yes | No — vectorize! |
| Compute mean of each row | Yes | No — `axis=1` |
| Euler time stepping | **No** — $y_{n+1}$ needs $y_n$ | **Yes** |
| Running sum / cumulative | **No** — each sum needs the previous | **Yes** |

::: {.fragment}
**The rule:** If step $n+1$ depends on the result of step $n$, you **must** use a loop.
:::

## Visualizing the Dependency {.tiny}

```
Independent (vectorize!):

    x₀ → f(x₀)       Each computation stands alone.
    x₁ → f(x₁)       You can do them all at once.
    x₂ → f(x₂)       NumPy handles this in C.
    x₃ → f(x₃)


Sequential (loop required):

    y₀ ──▶ y₁ ──▶ y₂ ──▶ y₃ ──▶ ...
      Euler   Euler   Euler   Euler

    Each arrow REQUIRES the previous value to exist.
    You can't skip ahead. This is a sequential chain.
```

::: {.fragment}
**This is the defining feature of time integration**, and it's why we can't just vectorize the whole thing in one NumPy call.
:::

# Summary {background-color="#9CA898"}

## What to Remember {.tiny}

| Concept | What went wrong | What to remember |
|---------|----------------|-----------------|
| The date | You forgot it existed | the date |
| Nested loops | Iterated over values instead of indices | `for ii in range(n_rows):` `for jj in range(n_cols):` `array[ii, jj]` |
| Why loops for integration | Answers were too vague | $y_{n+1}$ depends on $y_n$, sequential dependencies require a loop |

